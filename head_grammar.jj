options {
    STATIC = false;
}


PARSER_BEGIN(MyParser)

package compiler.frontend;

import java.util.*;
import compiler.frontend.ast.*;
import compiler.infra.SourceLocation;

public class MyParser {
    public static void main(String[] args) {
        try {
            MyParser parser = new MyParser(System.in);
            ASTNode prog = parser.Program();
            System.out.println(prog.toASTTestTree().toString());
        } catch (TokenMgrError e) {
            // Lexer-level error: illegal character or token
            System.err.println("LEXER ERROR: " + e.getMessage());
        } catch (ParseException e) {
            // Parser-level error: bad syntax
            System.err.println("PARSE ERROR: " + e.getMessage());
        }
    }

    private ASTNode setLoc(ASTNode n, Token t) {
        if (n != null && t != null) {
            n.setSourceLocation(new SourceLocation(null, t.beginLine, t.beginColumn));
        }
        return n;
    }
}


PARSER_END(MyParser)

// ---------- Tokens ----------
SKIP : { " " | "\t" | "\n" | "\r" }
SKIP : { < "//" (~["\n"])* ("\n"|"\r"|"\r\n") > }
SKIP : { < "/*" ( ~["*"] | "*" ~["/"] )* "*/" >}

TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < FOR: "for" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < TRUE: "true" > }
TOKEN : { < FALSE: "false" > }
TOKEN : { < NULL: "null" > }
TOKEN : { < NEW: "new" > }

TOKEN : { < CLASS: "class" > }
TOKEN : { < PUBLIC: "public" > }
TOKEN : { < STATIC: "static" > }
TOKEN : { < THIS: "this" > }

TOKEN : { < INT_LITERAL: (["0"-"9"])+ > }
TOKEN : { < STRING_LITERAL: "\"" (~["\"","\\"])* "\"" > }

TOKEN : { < EQ: "==" > }
TOKEN : { < ASSIGN: "=" > }
TOKEN : { < INCR: "++" > }
TOKEN : { < DECR: "--" > }
TOKEN : { < PLUS: "+" > }
TOKEN : { < MINUS: "-" > }
TOKEN : { < MULT: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < NEQ: "!=" > }
TOKEN : { < AND: "&&" > }
TOKEN : { < OR: "||" > }
TOKEN : { < NOT: "!" > }
TOKEN : { < DOT: "." > }
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < COMMA: "," > }

TOKEN : {
    < IDENTIFIER: (<LETTER>)(<LETTER>|<DIGIT>)* >
|
    < #LETTER: ["a"-"z","A"-"Z","_"] >
|
    < #DIGIT: ["0"-"9"] >
}
// ---------- Program ----------
ASTNode Program() :
{
    List<ASTNode> stmts = new ArrayList<>();
    ASTNode s;
}
{
    (
        LOOKAHEAD(ClassDecl()) s=ClassDecl() { stmts.add(s); }
      | s=Statement() { stmts.add(s); }
    )* <EOF>
    {
        return new BlockNode(stmts);
    }
}

ClassDeclNode ClassDecl() :
{
    Token t;
    List<VarDeclNode> fields = new ArrayList<>();
    List<FunctionDeclNode> methods = new ArrayList<>();
    ASTNode member;
}
{
    <CLASS> t=<IDENTIFIER> <LBRACE>
    (
        LOOKAHEAD( ( <INT> | <IDENTIFIER> ) <IDENTIFIER> ( <SEMI> | <ASSIGN> ) )
        member=VarDecl() { fields.add((VarDeclNode)member); }
      |
        LOOKAHEAD(ConstructorDecl())
        member=ConstructorDecl() { methods.add((FunctionDeclNode)member); }
      |
        member=FunctionDecl() { methods.add((FunctionDeclNode)member); }
    )*
    <RBRACE>
    {
        ClassDeclNode n = new ClassDeclNode(t.image, fields, methods);
        return (ClassDeclNode) setLoc(n, t);
    }
}

FunctionDeclNode ConstructorDecl() :
{
    Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    ( <PUBLIC> | <STATIC> )*
    id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        FunctionDeclNode n = new FunctionDeclNode(id.image, id.image, params, body);
        return (FunctionDeclNode) setLoc(n, id);
    }
}

// ---------- Statements ----------
ASTNode Statement() :
{
    ASTNode n;
}
{
      LOOKAHEAD( ( <INT> | <IDENTIFIER> ) <IDENTIFIER> ( <SEMI> | <ASSIGN> ) ) n=VarDecl() { return n; }
    | LOOKAHEAD( <IDENTIFIER> <ASSIGN> ) n=Assignment() { return n; }
    | n=IfStmt()        { return n; }
    | n=WhileStmt()     { return n; }
    | n=ForStmt()       { return n; }
    | n=Block()         { return n; }
    | LOOKAHEAD(FunctionDecl()) n=FunctionDecl()  { return n; }
    | n=ReturnStmt()    { return n; }
    | n=ExprOrAssignStmt() { return n; }
    | <SEMI>            { return new EmptyNode(); }
}

ASTNode ExprOrAssignStmt() :
{
    ExpressionNode e; ExpressionNode rhs=null;
}
{
    e=Expression()
    ( <ASSIGN> rhs=Expression() )?
    <SEMI>
    {
        if (rhs != null) {
            AssignmentNode n = new AssignmentNode(e, rhs);
            // We'd ideally like the location of the assignment operator or the left side,
            // but e already has a location.
            // setLoc(n, ???)
            // Let's use e's location if available? Or we don't track tokens here easily.
            // Since e is the start, we can copy its location.
            if (e.getSourceLocation() != null) n.setSourceLocation(e.getSourceLocation());
            return n;
        }
        return e;
    }
}

// Return
ASTNode ReturnStmt() :
{
    ExpressionNode expr = null;
    Token t;
}
{
    t=<RETURN> (expr=Expression())? <SEMI>
    {
        ReturnNode n = new ReturnNode(expr);
        return setLoc(n, t);
    }
}

// Declaration
ASTNode VarDecl() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )? <SEMI>
    {
        VarDeclNode n = new VarDeclNode(t.image, id.image, expr);
        return setLoc(n, t);
    }
}

// Assignment
AssignmentNode Assignment() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression() <SEMI>
    {
        IdentifierNode target = new IdentifierNode(id.image);
        setLoc(target, id);
        AssignmentNode n = new AssignmentNode(target, expr);
        return (AssignmentNode) setLoc(n, id);
    }
}

// Expr stmt
ASTNode ExprStmt() :
{
    ASTNode e;
}
{
    e=Expression() <SEMI>
    { return e; }
}

// ---------- Expressions ----------
ExpressionNode Expression() : { ExpressionNode n; } { n=LogicalOr() { return n; } }

ExpressionNode LogicalOr() :
{
    ExpressionNode left, right; Token op;
}
{
    left=LogicalAnd() ( op=<OR> right=LogicalAnd()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op); // Use operator location for binary op
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode LogicalAnd() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Equality() ( op=<AND> right=Equality()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op);
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode Equality() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Relational()
    ( (op=<EQ> | op=<NEQ>) right=Relational()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op);
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode Relational() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Additive()
    ( (op=<LT> | op=<GT>) right=Additive()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op);
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode Additive() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Term()
    ( (op=<PLUS> | op=<MINUS>) right=Term()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op);
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode Term() :
{
    ExpressionNode left, right; Token op;
}
{
    left = UnaryExpression()
    ( (op=<MULT> | op=<DIV>) right=UnaryExpression()
        {
          BinaryOpNode n = new BinaryOpNode(op.image, left, right);
          setLoc(n, op);
          left = n;
        }
    )*
    { return left; }
}

ExpressionNode UnaryExpression() :
{
    ExpressionNode e; Token op;
}
{
      ( op=<PLUS> | op=<MINUS> | op=<NOT> ) e=UnaryExpression()
      {
          UnaryOpNode n = new UnaryOpNode(op.image, e);
          return (UnaryOpNode) setLoc(n, op);
      }
    | e=Factor()
      { return e; }
}

ExpressionNode Factor() :
{
    ExpressionNode n; Token t; List<ExpressionNode> args = null;
}
{
    (
          t=<INT_LITERAL> { n = new LiteralNode(t.image); setLoc(n, t); }
        | t=<STRING_LITERAL> { n = new LiteralNode(t.image); setLoc(n, t); }
        | t=<TRUE> { n = new LiteralNode("true"); setLoc(n, t); }
        | t=<FALSE> { n = new LiteralNode("false"); setLoc(n, t); }
        | t=<NULL> { n = new LiteralNode("null"); setLoc(n, t); }
        | t=<THIS> { n = new IdentifierNode("this"); setLoc(n, t); }
        | n=NewExpr()
        | <LPAREN> n=Expression() <RPAREN>
        | t=<IDENTIFIER>
          (
              <LPAREN> [ args=ArgList() ] <RPAREN>
              {
                  n = new MethodCallNode(null, t.image, args == null ? new ArrayList<>() : args);
                  args = null;
                  setLoc(n, t);
              }
            |
              { n = new IdentifierNode(t.image); setLoc(n, t); }
          )
    )
    (
         LOOKAHEAD(<DOT> <IDENTIFIER> <LPAREN>) <DOT> t=<IDENTIFIER> <LPAREN> [ args=ArgList() ] <RPAREN>
         {
             n = new MethodCallNode(n, t.image, args == null ? new ArrayList<>() : args);
             args = null;
             setLoc(n, t);
         }
       |
         <DOT> t=<IDENTIFIER>
         {
             n = new MemberAccessNode(n, t.image);
             setLoc(n, t);
         }
       |
         <INCR> { n = new UnaryOpNode("post++", n); if(n.getSourceLocation()==null && n instanceof UnaryOpNode) ((UnaryOpNode)n).expr.getSourceLocation(); /* approx */ }
       |
         <DECR> { n = new UnaryOpNode("post--", n); }
    )*
    { return n; }
}

ExpressionNode NewExpr() :
{
    Token t; List<ExpressionNode> args = new ArrayList<>();
    Token start;
}
{
    start=<NEW> t=<IDENTIFIER> <LPAREN> [ args=ArgList() ] <RPAREN>
    {
        NewExprNode n = new NewExprNode(t.image, args);
        return (NewExprNode) setLoc(n, start);
    }
}

List<ExpressionNode> ArgList() :
{
    List<ExpressionNode> args = new ArrayList<>();
    ExpressionNode e;
}
{
    e=Expression() { args.add(e); }
    ( <COMMA> e=Expression() { args.add(e); } )*
    { return args; }
}

// ---------- Control Structures ----------
ASTNode IfStmt() :
{
    ExpressionNode cond; ASTNode thenBlock; ASTNode elseBlock=null;
    Token t;
}
{
    t=<IF> <LPAREN> cond=Expression() <RPAREN> thenBlock=Block()
    ( <ELSE> (
          LOOKAHEAD(1) elseBlock=Block()
        | elseBlock=IfStmt()
    ) )?
    {
        IfNode n = new IfNode(cond, thenBlock, elseBlock);
        return setLoc(n, t);
    }
}

ASTNode WhileStmt() :
{
    ExpressionNode cond; BlockNode body;
    Token t;
}
{
    t=<WHILE> <LPAREN> cond=Expression() <RPAREN> body=Block()
    {
        WhileNode n = new WhileNode(cond, body);
        return setLoc(n, t);
    }
}

// Productions for for-loop
VarDeclNode VarDeclForLoop() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )?
    {
        VarDeclNode n = new VarDeclNode(t.image, id.image, expr);
        return (VarDeclNode) setLoc(n, t);
    }
}

AssignmentNode AssignmentForLoop() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression()
    {
        IdentifierNode target = new IdentifierNode(id.image);
        setLoc(target, id);
        AssignmentNode n = new AssignmentNode(target, expr);
        return (AssignmentNode) setLoc(n, id);
    }
}

ASTNode ForStmt() :
{
    ExpressionNode cond=null, update=null; BlockNode body; VarDeclNode vardeclinit=null; AssignmentNode assignmentinit=null;
    Token t;
}
{
    t=<FOR> <LPAREN>
        [
            LOOKAHEAD(VarDeclForLoop()) vardeclinit=VarDeclForLoop()
          | assignmentinit=AssignmentForLoop()
        ] <SEMI>
        [ cond=Expression() ] <SEMI>
        [ update=Expression() ] <RPAREN>
        body=Block()
    {
        ForNode returnMe =null;
        if (vardeclinit != null) {
            returnMe = new ForNode(vardeclinit, cond, update, body);
        }
        else if (assignmentinit != null) {
            returnMe = new ForNode(assignmentinit, cond, update, body);
        }

        if (returnMe == null) {
             returnMe = new ForNode((StatementNode)null, cond, update, body);
        }

        return setLoc(returnMe, t);
    }
}

BlockNode Block() :
{
    List<ASTNode> stmts = new ArrayList<>(); ASTNode s;
    Token t;
}
{
    t=<LBRACE> ( s=Statement() { stmts.add(s); } )* <RBRACE>
    {
        BlockNode n = new BlockNode(stmts);
        return (BlockNode) setLoc(n, t);
    }
}

ASTNode FunctionDecl() :
{
    Token t; Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    ( <PUBLIC> | <STATIC> )*
    (t=<VOID> | t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        FunctionDeclNode n = new FunctionDeclNode(t.image, id.image, params, body);
        return (FunctionDeclNode) setLoc(n, t);
    }
}

List<VarDeclNode> ParamList() :
{
    List<VarDeclNode> params = new ArrayList<>();
    Token t, id;
    VarDeclNode p;
}
{
    ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
    {
        p = new VarDeclNode(t.image, id.image, null);
        setLoc(p, t);
        params.add(p);
    }

    ( <COMMA> ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
      {
        p = new VarDeclNode(t.image, id.image, null);
        setLoc(p, t);
        params.add(p);
      }
    )*

    { return params; }
}
