options {
    STATIC = false;
}


PARSER_BEGIN(MyParser)

package compiler.frontend;

import java.util.*;
import compiler.frontend.ast.*;

public class MyParser {
    public static void main(String[] args) {
        try {
            MyParser parser = new MyParser(System.in);
            ASTNode prog = parser.Program();
            System.out.println(prog.toASTTestTree().toString());
        } catch (TokenMgrError e) {
            // Lexer-level error: illegal character or token
            System.err.println("LEXER ERROR: " + e.getMessage());
        } catch (ParseException e) {
            // Parser-level error: bad syntax
            System.err.println("PARSE ERROR: " + e.getMessage());
        }
    }
        /*public MyParser(java.io.Reader reader) {
            this(new SimpleCharStream(reader, 1, 1));
        }
        */
    }


PARSER_END(MyParser)

// ---------- Tokens ----------
SKIP : { " " | "\t" | "\n" | "\r" }
SKIP : { < "//" (~["\n"])* ("\n"|"\r"|"\r\n") > }
SKIP : { < "/*" ( ~["*"] | "*" ~["/"] )* "*/" >}

TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < FOR: "for" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < TRUE: "true" > }
TOKEN : { < FALSE: "false" > }
TOKEN : { < NULL: "null" > }
TOKEN : { < NEW: "new" > }     

TOKEN : { < CLASS: "class" > }
TOKEN : { < PUBLIC: "public" > }
TOKEN : { < STATIC: "static" > }
TOKEN : { < THIS: "this" > }

TOKEN : { < INT_LITERAL: (["0"-"9"])+ > }
TOKEN : { < STRING_LITERAL: "\"" (~["\"","\\"])* "\"" > }

TOKEN : { < EQ: "==" > }
TOKEN : { < ASSIGN: "=" > }
TOKEN : { < INCR: "++" > }
TOKEN : { < DECR: "--" > }
TOKEN : { < PLUS: "+" > }
TOKEN : { < MINUS: "-" > }
TOKEN : { < MULT: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < NEQ: "!=" > }
TOKEN : { < AND: "&&" > }
TOKEN : { < OR: "||" > }
TOKEN : { < NOT: "!" > }
TOKEN : { < DOT: "." > }
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < LBRACKET: "[" > }
TOKEN : { < RBRACKET: "]" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < COMMA: "," > }

TOKEN : {
    < IDENTIFIER: (<LETTER>)(<LETTER>|<DIGIT>)* >
|
    < #LETTER: ["a"-"z","A"-"Z","_"] >
|
    < #DIGIT: ["0"-"9"] >
}

// ---------- Program ----------
ASTNode Program() :
{
    List<ASTNode> stmts = new ArrayList<>();
    ASTNode s;
}
{
    (
        s=Statement() { stmts.add(s); }
      | s=ClassDecl() { stmts.add(s); }
    )* <EOF>
    {
        return new BlockNode(stmts);
    }
}

// ---------- Helper ----------
String Type() :
{
    Token t;
    StringBuilder sb = new StringBuilder();
}
{
    ( t=<INT> | t=<VOID> | t=<IDENTIFIER> ) { sb.append(t.image); }
    ( <LBRACKET> <RBRACKET> { sb.append("[]"); } )*
    { return sb.toString(); }
}

// ---------- Statements ----------
ASTNode Statement() :
{
    ASTNode n;
}
{
      LOOKAHEAD(Type() <IDENTIFIER> (<ASSIGN>|<SEMI>)) n=VarDecl()       { return n; }
    | n=IfStmt()        { return n; }
    | n=WhileStmt()     { return n; }
    | n=ForStmt()       { return n; }
    | n=Block()         { return n; }
    | LOOKAHEAD(Type() <IDENTIFIER> <LPAREN>) n=FunctionDecl()  { return n; }
    | n=ReturnStmt()    { return n; }
    | n=ExprOrAssignStmt()      { return n; }
    | <SEMI>            { return new EmptyNode(); }
}

ASTNode ClassDecl() :
{
    Token name;
    FunctionDeclNode method;
    VarDeclNode field;
    List<VarDeclNode> fields = new ArrayList<>();
    List<FunctionDeclNode> methods = new ArrayList<>();
}
{
    <CLASS> name=<IDENTIFIER> <LBRACE>
    (
        ( <PUBLIC> | <STATIC> )*
        (
              LOOKAHEAD(Type() <IDENTIFIER> <LPAREN>) method=FunctionDecl() { methods.add(method); }
            | LOOKAHEAD(<IDENTIFIER> <LPAREN>) method=ConstructorDecl() { methods.add(method); }
            | field=VarDecl() { fields.add(field); }
        )
    )*
    <RBRACE>
    {
        return new ClassDeclNode(name.image, fields, methods);
    }
}

// Return
ASTNode ReturnStmt() :
{
    ExpressionNode expr = null;
}
{
    <RETURN> (expr=Expression())? <SEMI>
    {
        return new ReturnNode(expr);
    }
}

// Declaration
VarDeclNode VarDecl() :
{
    String type; Token id; ExpressionNode expr = null;
}
{
    type=Type() id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )? <SEMI>
    {
        return new VarDeclNode(type, id.image, expr);
    }
}

// Assignment or Expression Statement
ASTNode ExprOrAssignStmt() :
{
    ExpressionNode e; ExpressionNode val=null;
}
{
    e=Expression()
    ( <ASSIGN> val=Expression() )?
    <SEMI>
    {
        if (val == null) return e; // ExprStmt
        return new AssignmentNode(e, val);
    }
}

// Assignment in loop
AssignmentNode AssignmentForLoop() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression()
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

// ---------- Expressions ----------
ExpressionNode Expression() : { ExpressionNode n; } { n=LogicalOr() { return n; } }

ExpressionNode LogicalOr() :
{
    ExpressionNode left, right; Token op;
}
{
    left=LogicalAnd() ( op=<OR> right=LogicalAnd()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode LogicalAnd() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Equality() ( op=<AND> right=Equality()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Equality() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Relational() 
    ( (op=<EQ> | op=<NEQ>) right=Relational()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Relational() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Additive() 
    ( (op=<LT> | op=<GT>) right=Additive()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Additive() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Term()
    ( (op=<PLUS> | op=<MINUS>) right=Term()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Term() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Unary()
    ( (op=<MULT> | op=<DIV>) right=Unary()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Unary() :
{
    Token op; ExpressionNode e;
}
{
      (op=<PLUS>|op=<MINUS>|op=<NOT>) e=Unary()
      { return new UnaryOpNode(op.image, e); }
    | e=Factor()
      { return e; }
}

ExpressionNode Factor() :
{
    Token t;
    ExpressionNode result;
}
{
    (
          t=<INT_LITERAL>     { result = new LiteralNode(t.image); }
        | t=<STRING_LITERAL>  { result = new LiteralNode(t.image); }
        | t=<TRUE>            { result = new LiteralNode("true"); }
        | t=<FALSE>           { result = new LiteralNode("false"); }
        | t=<NULL>            { result = new LiteralNode("null"); }
        | t=<THIS>            { result = new IdentifierNode("this"); }
        | t=<IDENTIFIER>      { result = new IdentifierNode(t.image); }
        | <LPAREN> result=Expression() <RPAREN>
        | <NEW>
          (
              LOOKAHEAD(<IDENTIFIER> <LPAREN>)
              t=<IDENTIFIER> <LPAREN>
              {
                  List<ExpressionNode> args = new ArrayList<>();
                  ExpressionNode arg;
              }
              ( arg=Expression() { args.add(arg); } ( <COMMA> arg=Expression() { args.add(arg); } )* )?
              <RPAREN>
              { result = new NewExprNode(t.image, args); }
            |
              { String typeName; ExpressionNode size=null; }
              ( <INT> {typeName="int";} | <VOID> {typeName="void";} | t=<IDENTIFIER> {typeName=t.image;} )
              <LBRACKET> size=Expression() <RBRACKET>
              {
                  List<ExpressionNode> dims = new ArrayList<>();
                  if (size!=null) dims.add(size);
                  result = new NewExprNode(typeName + "[]", dims);
              }
          )
    )
    (
          <INCR> { result = new UnaryOpNode("post++", result); }
        | <DECR> { result = new UnaryOpNode("post--", result); }
        | <DOT> t=<IDENTIFIER> { result = new MemberAccessNode(result, t.image); }
        | <LPAREN>
            {
               List<ExpressionNode> args = new ArrayList<>();
               ExpressionNode arg;
            }
            ( arg=Expression() { args.add(arg); }
              ( <COMMA> arg=Expression() { args.add(arg); } )*
            )?
            <RPAREN>
            {
               if (result instanceof IdentifierNode) {
                    result = new MethodCallNode(null, ((IdentifierNode)result).name, args);
               } else if (result instanceof MemberAccessNode) {
                    MemberAccessNode ma = (MemberAccessNode)result;
                    result = new MethodCallNode(ma.object, ma.memberName, args);
               } else {
                    // Fallback
               }
            }
    )*
    { return result; }
}

// ---------- Control Structures ----------
ASTNode IfStmt() :
{
    ExpressionNode cond; ASTNode thenBlock; ASTNode elseBlock=null;
}
{
    <IF> <LPAREN> cond=Expression() <RPAREN>
    ( thenBlock=Block() | thenBlock=Statement() )
    ( <ELSE> ( elseBlock=Block() | elseBlock=Statement() ) )?
    {
        return new IfNode(cond, thenBlock, elseBlock);
    }
}

ASTNode WhileStmt() :
{
    ExpressionNode cond; ASTNode body;
}
{
    <WHILE> <LPAREN> cond=Expression() <RPAREN> ( body=Block() | body=Statement() )
    {
        return new WhileNode(cond, body);
    }
}

// Productions for for-loop
VarDeclNode VarDeclForLoop() :
{
    String type; Token id; ExpressionNode expr = null;
}
{
    type=Type() id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )?
    {
        return new VarDeclNode(type, id.image, expr);
    }
}

ASTNode ForStmt() :
{
    ExpressionNode cond=null, update=null; ASTNode body; VarDeclNode vardeclinit=null; AssignmentNode assignmentinit=null;
}
{
    <FOR> <LPAREN>
        [
            LOOKAHEAD(VarDeclForLoop()) vardeclinit=VarDeclForLoop()
            | assignmentinit=AssignmentForLoop()
        ] <SEMI>
        [ cond=Expression() ] <SEMI>
        [ update=Expression() ] <RPAREN>
        ( body=Block() | body=Statement() )
    {
        ForNode returnMe =null;
        if (vardeclinit != null) {
            returnMe = new ForNode(vardeclinit, cond, update, body);
        }
        else if (assignmentinit != null) {
            returnMe = new ForNode(assignmentinit, cond, update, body);
        }
        else {
             // Handle empty init
             returnMe = new ForNode(null, cond, update, body);
        }
        return returnMe;
    }
}

BlockNode Block() :
{
    List<ASTNode> stmts = new ArrayList<>(); ASTNode s;
}
{
    <LBRACE> ( s=Statement() { stmts.add(s); } )* <RBRACE>
    {
        return new BlockNode(stmts);
    }
}

FunctionDeclNode FunctionDecl() :
{
    String type; Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    type=Type() id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode(type, id.image, params, body);
    }
}

FunctionDeclNode ConstructorDecl() :
{
    Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode("void", id.image, params, body);
    }
}

List<VarDeclNode> ParamList() :
{
    List<VarDeclNode> params = new ArrayList<>(); 
    String type; Token id;
}
{
    type=Type() id=<IDENTIFIER>
    { params.add(new VarDeclNode(type, id.image, null)); }

    ( <COMMA> type=Type() id=<IDENTIFIER>
      { params.add(new VarDeclNode(type, id.image, null)); }
    )*

    { return params; }
}
