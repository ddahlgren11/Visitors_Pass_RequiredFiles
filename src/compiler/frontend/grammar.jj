options {
    STATIC = false;
}


PARSER_BEGIN(MyParser)

package compiler.frontend;

import java.util.*;
import compiler.frontend.ast.*;

public class MyParser {
    public static void main(String[] args) {
        try {
            MyParser parser = new MyParser(System.in);
            ASTNode prog = parser.Program();
            System.out.println(prog.toASTTestTree().toString());
        } catch (TokenMgrError e) {
            // Lexer-level error: illegal character or token
            System.err.println("LEXER ERROR: " + e.getMessage());
        } catch (ParseException e) {
            // Parser-level error: bad syntax
            System.err.println("PARSE ERROR: " + e.getMessage());
        }
    }
        /*public MyParser(java.io.Reader reader) {
            this(new SimpleCharStream(reader, 1, 1));
        }
        */
    }


PARSER_END(MyParser)

// ---------- Tokens ----------
SKIP : { " " | "\t" | "\n" | "\r" }
SKIP : { < "//" (~["\n"])* ("\n"|"\r"|"\r\n") > }
SKIP : { < "/*" ( ~["*"] | "*" ~["/"] )* "*/" >}

TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < FOR: "for" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < TRUE: "true" > }
TOKEN : { < FALSE: "false" > }
TOKEN : { < NULL: "null" > }
TOKEN : { < NEW: "new" > }     

TOKEN : { < CLASS: "class" > }
TOKEN : { < PUBLIC: "public" > }
TOKEN : { < STATIC: "static" > }
TOKEN : { < THIS: "this" > }

TOKEN : { < INT_LITERAL: (["0"-"9"])+ > }
TOKEN : { < STRING_LITERAL: "\"" (~["\"","\\"])* "\"" > }

TOKEN : { < EQ: "==" > }
TOKEN : { < ASSIGN: "=" > }
TOKEN : { < INCR: "++" > }
TOKEN : { < DECR: "--" > }
TOKEN : { < PLUS: "+" > }
TOKEN : { < MINUS: "-" > }
TOKEN : { < MULT: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < NEQ: "!=" > }
TOKEN : { < AND: "&&" > }
TOKEN : { < OR: "||" > }
TOKEN : { < DOT: "." > }
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < COMMA: "," > }

TOKEN : {
    < IDENTIFIER: (<LETTER>)(<LETTER>|<DIGIT>)* >
|
    < #LETTER: ["a"-"z","A"-"Z","_"] >
|
    < #DIGIT: ["0"-"9"] >
}
// ---------- Program ----------
ASTNode Program() :
{
    List<ASTNode> stmts = new ArrayList<>();
    ASTNode s;
}
{
    ( s=Statement() { stmts.add(s); } )* <EOF>
    {
        return new BlockNode(stmts);
    }
}

// ---------- Statements ----------
ASTNode Statement() :
{
    ASTNode n;
}
{
      n=VarDecl()       { return n; }
    | n=Assignment()    { return n; }
    | n=IfStmt()        { return n; }
    | n=WhileStmt()     { return n; }
    | n=ForStmt()       { return n; }
    | n=Block()         { return n; }
    | n=FunctionDecl()  { return n; }
    | n=ReturnStmt()    { return n; }
    | n=ExprStmt()      { return n; }
    | <SEMI>            { return new EmptyNode(); }
}

// Return
ASTNode ReturnStmt() :
{
    ExpressionNode expr = null;
}
{
    <RETURN> (expr=Expression())? <SEMI>
    {
        return new ReturnNode(expr);
    }
}

// Declaration
ASTNode VarDecl() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )? <SEMI>
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

// Assignment
AssignmentNode Assignment() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression() <SEMI>
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

// Expr stmt
ASTNode ExprStmt() :
{
    ASTNode e;
}
{
    LOOKAHEAD({ getToken(1).kind != RETURN })
    e=Expression() <SEMI> { return e; }
}

// ---------- Expressions ----------
ExpressionNode Expression() : { ExpressionNode n; } { n=LogicalOr() { return n; } }

ExpressionNode LogicalOr() :
{
    ExpressionNode left, right; Token op;
}
{
    left=LogicalAnd() ( op=<OR> right=LogicalAnd()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode LogicalAnd() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Equality() ( op=<AND> right=Equality()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Equality() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Relational() 
    ( (op=<EQ> | op=<NEQ>) right=Relational()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Relational() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Additive() 
    ( (op=<LT> | op=<GT>) right=Additive()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Additive() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Term()
    ( (op=<PLUS> | op=<MINUS>) right=Term()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Term() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Factor()
    ( (op=<MULT> | op=<DIV>) right=Factor()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Factor() :
{
    Token t; ExpressionNode e;
}
{
      t=<INT_LITERAL>     { return new LiteralNode(t.image); }
    | t=<STRING_LITERAL>  { return new LiteralNode(t.image); }
    | t=<TRUE>            { return new LiteralNode("true"); }
    | t=<FALSE>           { return new LiteralNode("false"); }
    | t=<NULL>            { return new LiteralNode("null"); }
    | t=<IDENTIFIER>
        (
            <INCR> { return new UnaryOpNode("post++", new IdentifierNode(t.image)); }
          | <DECR> { return new UnaryOpNode("post--", new IdentifierNode(t.image)); }
          |        { return new IdentifierNode(t.image); }
        )
    | <LPAREN> e=Expression() <RPAREN> { return e; }
}

// ---------- Control Structures ----------
ASTNode IfStmt() :
{
    ExpressionNode cond; BlockNode thenBlock, elseBlock=null;
}
{
    <IF> <LPAREN> cond=Expression() <RPAREN> thenBlock=Block()
    ( <ELSE> elseBlock=Block() )?
    {
        return new IfNode(cond, thenBlock, elseBlock);
    }
}

ASTNode WhileStmt() :
{
    ExpressionNode cond; BlockNode body;
}
{
    <WHILE> <LPAREN> cond=Expression() <RPAREN> body=Block()
    {
        return new WhileNode(cond, body);
    }
}

// Productions for for-loop
VarDeclNode VarDeclForLoop() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )?
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

AssignmentNode AssignmentForLoop() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression()
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

ASTNode ForStmt() :
{
    ExpressionNode cond=null, update=null; BlockNode body; VarDeclNode vardeclinit=null; AssignmentNode assignmentinit=null;
}
{
    <FOR> <LPAREN>
        [  assignmentinit=AssignmentForLoop() ] <SEMI>
        [ cond=Expression() ] <SEMI>
        [ update=Expression() ] <RPAREN>
        body=Block()
    {
        ForNode returnMe =null;
        if (vardeclinit != null) {
            returnMe = new ForNode(vardeclinit, cond, update, body);
        }
        else if (assignmentinit != null) {
            returnMe = new ForNode(assignmentinit, cond, update, body);
        }
        if (returnMe == null) {
            throw new RuntimeException("Something weird happened");
        }

        return returnMe;
    }
}

BlockNode Block() :
{
    List<ASTNode> stmts = new ArrayList<>(); ASTNode s;
}
{
    <LBRACE> ( s=Statement() { stmts.add(s); } )* <RBRACE>
    {
        return new BlockNode(stmts);
    }
}

ASTNode FunctionDecl() :
{
    Token t; Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    (t=<VOID> | t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode(t.image, id.image, params, body);
    }
}

List<VarDeclNode> ParamList() :
{
    List<VarDeclNode> params = new ArrayList<>(); 
    Token t, id;
}
{
    ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
    { params.add(new VarDeclNode(t.image, id.image, null)); }

    ( <COMMA> ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
      { params.add(new VarDeclNode(t.image, id.image, null)); }
    )*

    { return params; }
}