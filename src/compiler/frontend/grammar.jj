options {
    STATIC = false;
}


PARSER_BEGIN(MyParser)

package compiler.frontend;

import java.util.*;
import compiler.frontend.ast.*;

public class MyParser {
    private List<String> syntaxErrors = new ArrayList<>();

    public List<String> getSyntaxErrors() {
        return syntaxErrors;
    }

    public static void main(String[] args) {
        try {
            MyParser parser = new MyParser(System.in);
            ASTNode prog = parser.Program();
            System.out.println(prog.toASTTestTree().toString());

            for (String err : parser.getSyntaxErrors()) {
                System.err.println("PARSE ERROR: " + err);
            }
        } catch (TokenMgrError e) {
            // Lexer-level error: illegal character or token
            System.err.println("LEXER ERROR: " + e.getMessage());
        } catch (ParseException e) {
            // Parser-level error: bad syntax
            System.err.println("PARSE ERROR: " + e.getMessage());
        }
    }

    private void recover(ParseException e, int... skipTo) {
        syntaxErrors.add(e.getMessage());
        Token t;
        do {
            t = getToken(1);
            if (t.kind == EOF) break;
            for (int k : skipTo) {
                if (t.kind == k) {
                    // Found sync token.
                    // If it is SEMI, consume it to avoid infinite loop in loops that don't handle stray SEMI.
                    // If it is RBRACE, do NOT consume it, let the loop termination condition handle it.
                    if (k == SEMI) {
                        getNextToken();
                    }
                    return;
                }
            }
            getNextToken(); // Consume garbage
        } while (true);
    }
}


PARSER_END(MyParser)

// ---------- Tokens ----------
SKIP : { " " | "\t" | "\n" | "\r" }
SKIP : { < "//" (~["\n"])* ("\n"|"\r"|"\r\n") > }
SKIP : { < "/*" ( ~["*"] | "*" ~["/"] )* "*/" >}

TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < FOR: "for" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < TRUE: "true" > }
TOKEN : { < FALSE: "false" > }
TOKEN : { < NULL: "null" > }
TOKEN : { < NEW: "new" > }     

TOKEN : { < CLASS: "class" > }
TOKEN : { < PUBLIC: "public" > }
TOKEN : { < STATIC: "static" > }
TOKEN : { < THIS: "this" > }

TOKEN : { < INT_LITERAL: (["0"-"9"])+ > }
TOKEN : { < STRING_LITERAL: "\"" (~["\"","\\"])* "\"" > }
// Catch-all for malformed strings (unclosed before newline)
TOKEN : { < BAD_STRING: "\"" (~["\"","\\","\n","\r"])* > }

TOKEN : { < EQ: "==" > }
TOKEN : { < ASSIGN: "=" > }
TOKEN : { < INCR: "++" > }
TOKEN : { < DECR: "--" > }
TOKEN : { < PLUS: "+" > }
TOKEN : { < MINUS: "-" > }
TOKEN : { < MULT: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < NEQ: "!=" > }
TOKEN : { < AND: "&&" > }
TOKEN : { < OR: "||" > }
TOKEN : { < NOT: "!" > }
TOKEN : { < DOT: "." > }
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < COMMA: "," > }

TOKEN : {
    < IDENTIFIER: (<LETTER>)(<LETTER>|<DIGIT>)* >
|
    < #LETTER: ["a"-"z","A"-"Z","_"] >
|
    < #DIGIT: ["0"-"9"] >
}

// Catch-all for illegal characters. Must be last.
TOKEN : { < UNEXPECTED_CHAR: ~[] > }

// ---------- Program ----------
ASTNode Program() :
{
    List<ASTNode> stmts = new ArrayList<>();
    ASTNode s;
}
{
    (
        LOOKAHEAD(ClassDecl()) s=ClassDecl() { stmts.add(s); }
      | s=Statement() { stmts.add(s); }
    )* <EOF>
    {
        return new BlockNode(stmts);
    }
}

ClassDeclNode ClassDecl() :
{
    Token t;
    List<VarDeclNode> fields = new ArrayList<>();
    List<FunctionDeclNode> methods = new ArrayList<>();
    ASTNode member;
}
{
    <CLASS> t=<IDENTIFIER> <LBRACE>
    (
      try {
        (
            LOOKAHEAD( ( <INT> | <IDENTIFIER> ) <IDENTIFIER> ( <SEMI> | <ASSIGN> ) )
            member=VarDecl() { fields.add((VarDeclNode)member); }
          |
            LOOKAHEAD(ConstructorDecl())
            member=ConstructorDecl() { methods.add((FunctionDeclNode)member); }
          |
            member=FunctionDecl() { methods.add((FunctionDeclNode)member); }
          |
            <SEMI> // Allow extra semicolons in class body to prevent loop if recover doesn't consume it, or just for robustness
        )
      } catch (ParseException e) {
        recover(e, SEMI, RBRACE);
      }
    )*
    <RBRACE>
    {
        return new ClassDeclNode(t.image, fields, methods);
    }
}

FunctionDeclNode ConstructorDecl() :
{
    Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    ( <PUBLIC> | <STATIC> )*
    id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode(id.image, id.image, params, body);
    }
}

// ---------- Statements ----------
ASTNode Statement() :
{
    ASTNode n = new EmptyNode();
}
{
    try {
        (
              LOOKAHEAD( ( <INT> | <IDENTIFIER> ) <IDENTIFIER> ( <SEMI> | <ASSIGN> ) ) n=VarDecl() { return n; }
            | LOOKAHEAD( <IDENTIFIER> <ASSIGN> ) n=Assignment() { return n; }
            | n=IfStmt()        { return n; }
            | n=WhileStmt()     { return n; }
            | n=ForStmt()       { return n; }
            | n=Block()         { return n; }
            | LOOKAHEAD(FunctionDecl()) n=FunctionDecl()  { return n; }
            | n=ReturnStmt()    { return n; }
            | n=ExprOrAssignStmt() { return n; }
            | <SEMI>            { return new EmptyNode(); }
        )
    } catch (ParseException e) {
        recover(e, SEMI);
        return new EmptyNode();
    }
}

ASTNode ExprOrAssignStmt() :
{
    ExpressionNode e; ExpressionNode rhs=null;
}
{
    e=Expression()
    ( <ASSIGN> rhs=Expression() )?
    <SEMI>
    {
        if (rhs != null) return new AssignmentNode(e, rhs);
        return e;
    }
}

// Return
ASTNode ReturnStmt() :
{
    ExpressionNode expr = null;
}
{
    <RETURN> (expr=Expression())? <SEMI>
    {
        return new ReturnNode(expr);
    }
}

// Declaration
ASTNode VarDecl() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )? <SEMI>
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

// Assignment
AssignmentNode Assignment() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression() <SEMI>
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

// Expr stmt
ASTNode ExprStmt() :
{
    ASTNode e;
}
{
    e=Expression() <SEMI>
    { return e; }
}

// ---------- Expressions ----------
ExpressionNode Expression() : { ExpressionNode n; } { n=LogicalOr() { return n; } }

ExpressionNode LogicalOr() :
{
    ExpressionNode left, right; Token op;
}
{
    left=LogicalAnd() ( op=<OR> right=LogicalAnd()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode LogicalAnd() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Equality() ( op=<AND> right=Equality()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Equality() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Relational() 
    ( (op=<EQ> | op=<NEQ>) right=Relational()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Relational() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Additive() 
    ( (op=<LT> | op=<GT>) right=Additive()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Additive() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Term()
    ( (op=<PLUS> | op=<MINUS>) right=Term()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Term() :
{
    ExpressionNode left, right; Token op;
}
{
    left = UnaryExpression()
    ( (op=<MULT> | op=<DIV>) right=UnaryExpression()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode UnaryExpression() :
{
    ExpressionNode e; Token op;
}
{
      ( op=<PLUS> | op=<MINUS> | op=<NOT> ) e=UnaryExpression()
      { return new UnaryOpNode(op.image, e); }
    | e=Factor()
      { return e; }
}

ExpressionNode Factor() :
{
    ExpressionNode n; Token t; List<ExpressionNode> args = null;
}
{
    (
          t=<INT_LITERAL> { n = new LiteralNode(t.image); }
        | t=<STRING_LITERAL> { n = new LiteralNode(t.image); }
        | t=<TRUE> { n = new LiteralNode("true"); }
        | t=<FALSE> { n = new LiteralNode("false"); }
        | t=<NULL> { n = new LiteralNode("null"); }
        | t=<THIS> { n = new IdentifierNode("this"); }
        | n=NewExpr()
        | <LPAREN> n=Expression() <RPAREN>
        | t=<IDENTIFIER>
          (
              <LPAREN> [ args=ArgList() ] <RPAREN>
              { n = new MethodCallNode(null, t.image, args == null ? new ArrayList<>() : args); args = null; }
            |
              { n = new IdentifierNode(t.image); }
          )
    )
    (
         LOOKAHEAD(<DOT> <IDENTIFIER> <LPAREN>) <DOT> t=<IDENTIFIER> <LPAREN> [ args=ArgList() ] <RPAREN>
         { n = new MethodCallNode(n, t.image, args == null ? new ArrayList<>() : args); args = null; }
       |
         <DOT> t=<IDENTIFIER>
         { n = new MemberAccessNode(n, t.image); }
       |
         <INCR> { n = new UnaryOpNode("post++", n); }
       |
         <DECR> { n = new UnaryOpNode("post--", n); }
    )*
    { return n; }
}

ExpressionNode NewExpr() :
{
    Token t; List<ExpressionNode> args = new ArrayList<>();
}
{
    <NEW> t=<IDENTIFIER> <LPAREN> [ args=ArgList() ] <RPAREN>
    { return new NewExprNode(t.image, args); }
}

List<ExpressionNode> ArgList() :
{
    List<ExpressionNode> args = new ArrayList<>();
    ExpressionNode e;
}
{
    e=Expression() { args.add(e); }
    ( <COMMA> e=Expression() { args.add(e); } )*
    { return args; }
}

// ---------- Control Structures ----------
ASTNode IfStmt() :
{
    ExpressionNode cond; ASTNode thenBlock; ASTNode elseBlock=null;
}
{
    <IF> <LPAREN> cond=Expression() <RPAREN> thenBlock=Block()
    ( <ELSE> (
          LOOKAHEAD(1) elseBlock=Block()
        | elseBlock=IfStmt()
    ) )?
    {
        return new IfNode(cond, thenBlock, elseBlock);
    }
}

ASTNode WhileStmt() :
{
    ExpressionNode cond; BlockNode body;
}
{
    <WHILE> <LPAREN> cond=Expression() <RPAREN> body=Block()
    {
        return new WhileNode(cond, body);
    }
}

// Productions for for-loop
VarDeclNode VarDeclForLoop() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )?
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

AssignmentNode AssignmentForLoop() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression()
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

ASTNode ForStmt() :
{
    ExpressionNode cond=null, update=null; BlockNode body; VarDeclNode vardeclinit=null; AssignmentNode assignmentinit=null;
}
{
    <FOR> <LPAREN>
        [
            LOOKAHEAD(VarDeclForLoop()) vardeclinit=VarDeclForLoop()
          | assignmentinit=AssignmentForLoop()
        ] <SEMI>
        [ cond=Expression() ] <SEMI>
        [ update=Expression() ] <RPAREN>
        body=Block()
    {
        ForNode returnMe =null;
        if (vardeclinit != null) {
            returnMe = new ForNode(vardeclinit, cond, update, body);
        }
        else if (assignmentinit != null) {
            returnMe = new ForNode(assignmentinit, cond, update, body);
        }
        if (returnMe == null) {
             returnMe = new ForNode((StatementNode)null, cond, update, body);
        }

        return returnMe;
    }
}

BlockNode Block() :
{
    List<ASTNode> stmts = new ArrayList<>(); ASTNode s;
}
{
    <LBRACE> ( s=Statement() { stmts.add(s); } )* <RBRACE>
    {
        return new BlockNode(stmts);
    }
}

ASTNode FunctionDecl() :
{
    Token t; Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    ( <PUBLIC> | <STATIC> )*
    (t=<VOID> | t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode(t.image, id.image, params, body);
    }
}

List<VarDeclNode> ParamList() :
{
    List<VarDeclNode> params = new ArrayList<>(); 
    Token t, id;
}
{
    ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
    { params.add(new VarDeclNode(t.image, id.image, null)); }

    ( <COMMA> ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
      { params.add(new VarDeclNode(t.image, id.image, null)); }
    )*

    { return params; }
}
