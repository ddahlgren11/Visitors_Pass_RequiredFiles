options {
    STATIC = false;
}


PARSER_BEGIN(MyParser)

package compiler.frontend;

import java.util.*;
import compiler.frontend.ast.*;

public class MyParser {
    public static void main(String[] args) {
        try {
            MyParser parser = new MyParser(System.in);
            ASTNode prog = parser.Program();
            System.out.println(prog.toASTTestTree().toString());
        } catch (TokenMgrError e) {
            // Lexer-level error: illegal character or token
            System.err.println("LEXER ERROR: " + e.getMessage());
        } catch (ParseException e) {
            // Parser-level error: bad syntax
            System.err.println("PARSE ERROR: " + e.getMessage());
        }
    }
        /*public MyParser(java.io.Reader reader) {
            this(new SimpleCharStream(reader, 1, 1));
        }
        */
    }


PARSER_END(MyParser)

// ---------- Tokens ----------
SKIP : { " " | "\t" | "\n" | "\r" }
SKIP : { < "//" (~["\n"])* ("\n"|"\r"|"\r\n") > }
SKIP : { < "/*" ( ~["*"] | "*" ~["/"] )* "*/" >}

TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < FOR: "for" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < TRUE: "true" > }
TOKEN : { < FALSE: "false" > }
TOKEN : { < NULL: "null" > }
TOKEN : { < NEW: "new" > }     

TOKEN : { < CLASS: "class" > }
TOKEN : { < PUBLIC: "public" > }
TOKEN : { < STATIC: "static" > }
TOKEN : { < THIS: "this" > }

TOKEN : { < INT_LITERAL: (["0"-"9"])+ > }
TOKEN : { < STRING_LITERAL: "\"" (~["\"","\\"])* "\"" > }

TOKEN : { < EQ: "==" > }
TOKEN : { < ASSIGN: "=" > }
TOKEN : { < INCR: "++" > }
TOKEN : { < DECR: "--" > }
TOKEN : { < PLUS: "+" > }
TOKEN : { < MINUS: "-" > }
TOKEN : { < MULT: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < NEQ: "!=" > }
TOKEN : { < AND: "&&" > }
TOKEN : { < OR: "||" > }
TOKEN : { < DOT: "." > }
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < COMMA: "," > }

TOKEN : {
    < IDENTIFIER: (<LETTER>)(<LETTER>|<DIGIT>)* >
|
    < #LETTER: ["a"-"z","A"-"Z","_"] >
|
    < #DIGIT: ["0"-"9"] >
}
// ---------- Program ----------
ASTNode Program() :
{
    List<ASTNode> stmts = new ArrayList<>();
    ASTNode s;
}
{
    (
      LOOKAHEAD(2) s=ClassDecl() { stmts.add(s); }
    | s=Statement() { stmts.add(s); }
    )* <EOF>
    {
        return new BlockNode(stmts);
    }
}

// ---------- Classes ----------
ClassDeclNode ClassDecl() :
{
    Token t;
    List<VarDeclNode> fields = new ArrayList<>();
    List<FunctionDeclNode> methods = new ArrayList<>();
    Token type, name;
}
{
    <CLASS> t=<IDENTIFIER> <LBRACE>
    (
        MemberDecl(fields, methods)
    )*
    <RBRACE>
    {
        return new ClassDeclNode(t.image, fields, methods);
    }
}

void MemberDecl(List<VarDeclNode> fields, List<FunctionDeclNode> methods) :
{
    Token t;
    boolean isPublic = false;
    boolean isStatic = false;
}
{
    ( <PUBLIC> { isPublic = true; } )?
    ( <STATIC> { isStatic = true; } )?

    (
        t=<IDENTIFIER>
        (
            LOOKAHEAD(<LPAREN>)
            ConstructorDeclRest(t, methods)
            |
            MemberFieldOrMethodRest(t, fields, methods)
        )
    |
        ( t=<INT> | t=<VOID> )
        MemberFieldOrMethodRest(t, fields, methods)
    )
}

void ConstructorDeclRest(Token id, List<FunctionDeclNode> methods) :
{
    List<VarDeclNode> params = new ArrayList<>();
    BlockNode body;
}
{
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        // Treat constructor as a function with special return type same as class name (id.image).
        methods.add(new FunctionDeclNode(id.image, id.image, params, body));
    }
}

void MemberFieldOrMethodRest(Token type, List<VarDeclNode> fields, List<FunctionDeclNode> methods) :
{
    Token name;
    List<VarDeclNode> params = new ArrayList<>();
    BlockNode body;
    ExpressionNode initExpr = null;
}
{
    name=<IDENTIFIER>
    (
        // Method
        <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
        {
            methods.add(new FunctionDeclNode(type.image, name.image, params, body));
        }
    |
        // Field
        ( <ASSIGN> initExpr=Expression() )? <SEMI>
        {
            fields.add(new VarDeclNode(type.image, name.image, initExpr));
        }
    )
}

// ---------- Statements ----------
ASTNode Statement() :
{
    ASTNode n;
}
{
      LOOKAHEAD( ( <INT> | <IDENTIFIER> ) <IDENTIFIER> ( <ASSIGN> | <SEMI> ) )
      n=VarDecl()       { return n; }
    | n=IfStmt()        { return n; }
    | n=WhileStmt()     { return n; }
    | n=ForStmt()       { return n; }
    | n=Block()         { return n; }
    | LOOKAHEAD( ( <VOID> | <INT> | <IDENTIFIER> ) <IDENTIFIER> <LPAREN> )
      n=FunctionDecl()  { return n; }
    | n=ReturnStmt()    { return n; }
    | n=ExprOrAssign()  { return n; }
    | <SEMI>            { return new EmptyNode(); }
}

ASTNode ExprOrAssign() :
{
    ExpressionNode lhs;
    ExpressionNode rhs=null;
}
{
    lhs=Expression()
    ( <ASSIGN> rhs=Expression() )?
    <SEMI>
    {
        if (rhs == null) {
            return lhs;
        } else {
            return new AssignmentNode(lhs, rhs);
        }
    }
}

// Return
ASTNode ReturnStmt() :
{
    ExpressionNode expr = null;
}
{
    <RETURN> (expr=Expression())? <SEMI>
    {
        return new ReturnNode(expr);
    }
}

// Declaration
ASTNode VarDecl() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )? <SEMI>
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

// Assignment (Kept for ForLoop usage if needed, or backward compat)
AssignmentNode Assignment() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression() <SEMI>
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

// Expr stmt
ASTNode ExprStmt() :
{
    ASTNode e;
}
{
    e=Expression() <SEMI>
    { return e; }
}

// ---------- Expressions ----------
ExpressionNode Expression() : { ExpressionNode n; } { n=LogicalOr() { return n; } }

ExpressionNode LogicalOr() :
{
    ExpressionNode left, right; Token op;
}
{
    left=LogicalAnd() ( op=<OR> right=LogicalAnd()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode LogicalAnd() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Equality() ( op=<AND> right=Equality()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Equality() :
{
    ExpressionNode left, right; Token op;
}
{
    left=Relational() 
    ( (op=<EQ> | op=<NEQ>) right=Relational()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Relational() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Additive() 
    ( (op=<LT> | op=<GT>) right=Additive()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Additive() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Term()
    ( (op=<PLUS> | op=<MINUS>) right=Term()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Term() :
{
    ExpressionNode left, right; Token op;
}
{
    left = Unary()
    ( (op=<MULT> | op=<DIV>) right=Unary()
        { left = new BinaryOpNode(op.image, left, right); }
    )*
    { return left; }
}

ExpressionNode Unary() :
{
    ExpressionNode e; Token op;
}
{
    ( op=<PLUS> | op=<MINUS> ) e=Unary()
    { return new UnaryOpNode(op.image, e); }
    |
    e=Factor() { return e; }
}

ExpressionNode Factor() :
{
    Token t; ExpressionNode e;
    ExpressionNode result;
    List<ExpressionNode> args = new ArrayList<>();
}
{
      t=<INT_LITERAL>     { return new LiteralNode(t.image); }
    | t=<STRING_LITERAL>  { return new LiteralNode(t.image); }
    | t=<TRUE>            { return new LiteralNode("true"); }
    | t=<FALSE>           { return new LiteralNode("false"); }
    | t=<NULL>            { return new LiteralNode("null"); }

    | <NEW> t=<IDENTIFIER> <LPAREN> [ args=ArgList() ] <RPAREN>
      { return new NewExprNode(t.image, args); }

    | t=<IDENTIFIER>
      {
          // default: just the identifier
          result = new IdentifierNode(t.image);
      }
      (
          <INCR> { result = new UnaryOpNode("post++", new IdentifierNode(t.image)); }
        | <DECR> { result = new UnaryOpNode("post--", new IdentifierNode(t.image)); }
        | <LPAREN> { args = new ArrayList<>(); } [ args=ArgList() ] <RPAREN>
          {
              // Local method call
              result = new MethodCallNode(null, t.image, args);
          }
        |
          // Method Call or Member Access
          (
            <DOT> t=<IDENTIFIER>
            (
                <LPAREN> { args = new ArrayList<>(); } [ args=ArgList() ] <RPAREN>
                {
                    result = new MethodCallNode(result, t.image, args);
                }
            |
                // Field access
                {
                    result = new MemberAccessNode(result, t.image);
                }
            )
          )+
      )?
      { return result; }

    | <THIS>
      { result = new IdentifierNode("this"); } // Treat 'this' as identifier or create ThisNode?
      (
          <DOT> t=<IDENTIFIER>
            (
                <LPAREN> { args = new ArrayList<>(); } [ args=ArgList() ] <RPAREN>
                {
                    result = new MethodCallNode(result, t.image, args);
                }
            |
                // Field access
                {
                    result = new MemberAccessNode(result, t.image);
                }
            )
      )*
      { return result; }

    | <LPAREN> e=Expression() <RPAREN> { return e; }
}

List<ExpressionNode> ArgList() :
{
    List<ExpressionNode> args = new ArrayList<>();
    ExpressionNode e;
}
{
    e=Expression() { args.add(e); }
    ( <COMMA> e=Expression() { args.add(e); } )*
    { return args; }
}

// ---------- Control Structures ----------
ASTNode IfStmt() :
{
    ExpressionNode cond; BlockNode thenBlock, elseBlock=null;
    ASTNode elseStmt=null;
}
{
    <IF> <LPAREN> cond=Expression() <RPAREN> thenBlock=Block()
    ( <ELSE>
      (
        elseBlock=Block()
        |
        elseStmt=IfStmt() { List<ASTNode> l = new ArrayList<>(); l.add(elseStmt); elseBlock = new BlockNode(l); }
      )
    )?
    {
        return new IfNode(cond, thenBlock, elseBlock);
    }
}

ASTNode WhileStmt() :
{
    ExpressionNode cond; BlockNode body;
}
{
    <WHILE> <LPAREN> cond=Expression() <RPAREN> body=Block()
    {
        return new WhileNode(cond, body);
    }
}

// Productions for for-loop
VarDeclNode VarDeclForLoop() :
{
    Token t; Token id; ExpressionNode expr = null;
}
{
    (t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER> ( <ASSIGN> expr=Expression() )?
    {
        return new VarDeclNode(t.image, id.image, expr);
    }
}

AssignmentNode AssignmentForLoop() :
{
    Token id; ExpressionNode expr;
}
{
    id=<IDENTIFIER> <ASSIGN> expr=Expression()
    {
        return new AssignmentNode(new IdentifierNode(id.image), expr);
    }
}

ASTNode ForStmt() :
{
    ExpressionNode cond=null, update=null; BlockNode body; VarDeclNode vardeclinit=null; AssignmentNode assignmentinit=null;
}
{
    <FOR> <LPAREN>
    (
        LOOKAHEAD(VarDeclForLoop()) vardeclinit=VarDeclForLoop()
      |
        assignmentinit=AssignmentForLoop()
    )?
    <SEMI>
    [ cond=Expression() ] <SEMI>
    [ update=Expression() ] <RPAREN>
    body=Block()
    {
        ForNode returnMe =null;
        if (vardeclinit != null) {
            returnMe = new ForNode(vardeclinit, cond, update, body);
        }
        else if (assignmentinit != null) {
            returnMe = new ForNode(assignmentinit, cond, update, body);
        }
        else {
            // Both null
            returnMe = new ForNode((VarDeclNode)null, cond, update, body);
        }

        return returnMe;
    }
}

BlockNode Block() :
{
    List<ASTNode> stmts = new ArrayList<>(); ASTNode s;
}
{
    <LBRACE> ( s=Statement() { stmts.add(s); } )* <RBRACE>
    {
        return new BlockNode(stmts);
    }
}

ASTNode FunctionDecl() :
{
    Token t; Token id; List<VarDeclNode> params = new ArrayList<>(); BlockNode body;
}
{
    (t=<VOID> | t=<INT> | t=<IDENTIFIER>) id=<IDENTIFIER>
    <LPAREN> ( params=ParamList() )? <RPAREN> body=Block()
    {
        return new FunctionDeclNode(t.image, id.image, params, body);
    }
}

List<VarDeclNode> ParamList() :
{
    List<VarDeclNode> params = new ArrayList<>(); 
    Token t, id;
}
{
    ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
    { params.add(new VarDeclNode(t.image, id.image, null)); }

    ( <COMMA> ( t=<INT> | t=<IDENTIFIER> ) id=<IDENTIFIER>
      { params.add(new VarDeclNode(t.image, id.image, null)); }
    )*

    { return params; }
}
